<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0a0a0a">
  <meta name="description" content="Retro Arcade - A personal retro game console in your browser">

  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%23ff6b35' width='192' height='192'/><text x='96' y='120' font-size='120' text-anchor='middle' fill='%230a0a0a' font-family='Arial'>üéÆ</text></svg>">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 192 192'><rect fill='%23ff6b35' width='192' height='192'/><text x='96' y='120' font-size='120' text-anchor='middle' fill='%230a0a0a' font-family='Arial'>üéÆ</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <title>Retro Arcade</title>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a0a0a;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      font-size: 16px;
    }

    body {
      overscroll-behavior: none;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    #app {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
    }

    /* ===== LIBRARY VIEW ===== */
    #libraryView {
      display: none;
      flex-direction: column;
      height: 100%;
      width: 100%;
      background: #0a0a0a;
    }

    #libraryView.active {
      display: flex;
    }

    .header {
      background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
      padding: 28px 20px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(255, 107, 53, 0.3);
      flex-shrink: 0;
    }

    .header h1 {
      font-family: "Press Start 2P", cursive;
      font-size: clamp(18px, 5vw, 36px);
      letter-spacing: 2px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      color: #0a0a0a;
      margin-bottom: 8px;
    }

    .header-subtitle {
      font-size: 14px;
      color: rgba(10, 10, 10, 0.85);
      letter-spacing: 0.5px;
    }

    .version-tag {
      font-size: 10px;
      color: rgba(10, 10, 10, 0.5);
      margin-top: 4px;
    }

    .library-content {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      -webkit-overflow-scrolling: touch;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      color: #999;
    }

    .empty-state-icon {
      font-size: 80px;
      margin-bottom: 24px;
      opacity: 0.7;
    }

    .empty-state p {
      font-size: 16px;
      line-height: 1.6;
      max-width: 320px;
      color: #bbb;
    }

    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 20px;
      margin-bottom: 100px;
    }

    .game-card {
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      border: 3px solid #ff6b35;
      border-radius: 8px;
      padding: 14px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 180px;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      -webkit-user-select: none;
      touch-action: manipulation;
      position: relative;
    }

    .game-card:active {
      transform: scale(0.97);
      border-color: #ff8c42;
    }

    .game-card:hover {
      box-shadow: 0 0 12px rgba(255, 107, 53, 0.6);
      border-color: #ff8c42;
    }

    .game-card-icon {
      font-size: 56px;
      margin-bottom: 12px;
      display: block;
    }

    .game-card-name {
      font-size: 14px;
      font-weight: 700;
      text-align: center;
      margin-bottom: 10px;
      line-height: 1.3;
      word-break: break-word;
      max-height: 40px;
      overflow: hidden;
      color: #fff;
    }

    .game-card-system {
      background: #ff6b35;
      color: #0a0a0a;
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 8px;
    }

    .game-card-hint {
      font-size: 11px;
      color: #888;
      margin-top: 4px;
    }

    .game-card-delete-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      background: rgba(255, 107, 53, 0.9);
      color: #0a0a0a;
      border: none;
      border-radius: 50%;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
      transition: all 0.2s ease;
    }

    .game-card:hover .game-card-delete-btn {
      display: flex;
    }

    .game-card-delete-btn:active {
      transform: scale(0.9);
    }

    .game-card-system.gb { background: #8ab83a; }
    .game-card-system.gba { background: #7c5295; }
    .game-card-system.segaMD { background: #0070cc; }
    .game-card-system.segaMS { background: #000; border: 1px solid #666; }
    .game-card-system.snes { background: #a946ef; }

    .add-button {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
      color: #0a0a0a;
      border: none;
      font-size: 42px;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 4px 16px rgba(255, 107, 53, 0.5);
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      touch-action: manipulation;
      flex-direction: column;
    }

    .add-button-label {
      font-size: 10px;
      font-weight: 600;
      margin-top: 2px;
      letter-spacing: 0.5px;
    }

    .add-button:active {
      transform: scale(0.9);
      box-shadow: 0 2px 8px rgba(255, 107, 53, 0.4);
    }

    .add-button:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(255, 107, 53, 0.6);
    }

    #fileInput {
      display: none;
    }

    /* ===== PLAYER VIEW ===== */
    #playerView {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100%;
      height: 100%;
      background: #000;
      z-index: 500;
    }

    #playerView.active {
      display: block;
    }

    #game-container {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
    }

    /* Make EmulatorJS scale properly inside the container */
    #game-container > div {
      width: 100% !important;
      height: 100% !important;
      max-width: 100vw !important;
      max-height: 100vh !important;
    }

    /* In puzzle mode: game container fills entire viewport */
    .puzzle-mode #game-container {
      width: 100vw !important;
      height: 100vh !important;
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
    }

    /* Custom touch overlay */
    #touchOverlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 450;
      touch-action: none;
    }

    #touchOverlay.active {
      display: block;
    }

    /* Visual feedback for touch gestures */
    .touch-feedback {
      position: fixed;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: rgba(255, 107, 53, 0.3);
      border: 2px solid rgba(255, 107, 53, 0.6);
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0);
      transition: transform 0.15s ease-out, opacity 0.3s ease;
      z-index: 460;
    }

    .touch-feedback.pop {
      transform: translate(-50%, -50%) scale(1);
      opacity: 0;
    }

    /* Hold indicator */
    .hold-indicator {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255, 255, 255, 0.5);
      font-size: 13px;
      pointer-events: none;
      z-index: 460;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .hold-indicator.visible {
      opacity: 1;
    }

    .back-button {
      position: fixed;
      top: 16px;
      left: 16px;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      border: 2px solid #ff6b35;
      padding: 12px 20px;
      border-radius: 4px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      z-index: 501;
      transition: opacity 0.3s ease;
      touch-action: manipulation;
      opacity: 0;
      pointer-events: none;
    }

    .back-button.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .back-button:active {
      transform: scale(0.95);
    }

    .back-button:hover {
      background: rgba(0, 0, 0, 0.9);
      border-color: #ff8c42;
    }

    .loading-screen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 502;
    }

    .loading-screen.active {
      display: flex;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 107, 53, 0.3);
      border-top-color: #ff6b35;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-text {
      color: #ff6b35;
      font-size: 14px;
      text-align: center;
    }

    /* ===== MODALS ===== */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: #1a1a1a;
      border: 2px solid #ff6b35;
      border-radius: 8px;
      padding: 24px;
      max-width: 90%;
      max-height: 80%;
      overflow-y: auto;
      box-shadow: 0 8px 32px rgba(255, 107, 53, 0.3);
    }

    .modal h2 {
      font-family: "Press Start 2P", cursive;
      font-size: 14px;
      margin-bottom: 20px;
      color: #ff6b35;
      letter-spacing: 1px;
    }

    .modal-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
    }

    .modal-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
    }

    .modal-button.primary {
      background: #ff6b35;
      color: #0a0a0a;
    }

    .modal-button.secondary {
      background: #333;
      color: #fff;
      border: 1px solid #666;
    }

    .modal-button:active {
      transform: scale(0.95);
    }

    .system-picker {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 12px;
    }

    .system-option {
      padding: 16px;
      background: #2a2a2a;
      border: 2px solid #444;
      border-radius: 6px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
      touch-action: manipulation;
    }

    .system-option:active {
      transform: scale(0.95);
    }

    .system-option:hover {
      border-color: #ff6b35;
      background: #333;
    }

    .system-option-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }

    .system-option-name {
      font-size: 12px;
      font-weight: 600;
      color: #fff;
    }

    .delete-modal p {
      color: #ccc;
      margin-bottom: 20px;
      font-size: 14px;
      line-height: 1.5;
    }

    .delete-modal .game-name {
      color: #ff6b35;
      font-weight: 600;
      word-break: break-word;
    }

    /* ===== SCROLLBAR ===== */
    .library-content::-webkit-scrollbar {
      width: 8px;
    }

    .library-content::-webkit-scrollbar-track {
      background: #0a0a0a;
    }

    .library-content::-webkit-scrollbar-thumb {
      background: #ff6b35;
      border-radius: 4px;
    }

    .library-content::-webkit-scrollbar-thumb:hover {
      background: #ff8c42;
    }

    /* ===== RESPONSIVE ===== */
    @media (max-width: 768px) {
      .games-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 18px;
      }

      .add-button {
        width: 75px;
        height: 75px;
        bottom: 24px;
        right: 24px;
        font-size: 38px;
      }

      .header h1 {
        font-size: clamp(18px, 4vw, 28px);
      }
    }

    @media (max-width: 480px) {
      .games-grid {
        grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
        gap: 16px;
      }

      .library-content {
        padding: 18px;
      }

      .game-card {
        min-height: 160px;
        padding: 12px;
      }

      .game-card-name {
        font-size: 13px;
      }

      .game-card-icon {
        font-size: 48px;
      }

      .add-button {
        width: 70px;
        height: 70px;
        font-size: 36px;
      }
    }

    /* ===== PUZZLE MODE ===== */
    /* Canvas-mirror approach: a black shield covers game-container (hiding EmulatorJS UI),
       while a mirror canvas copies game visuals via drawImage() every frame.
       ZERO CSS/JS targeting of EmulatorJS elements ‚Äî any targeting causes iOS crashes. */

    /* Black shield covers game-container entirely */
    #puzzleShield {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      z-index: 5;
    }
    .puzzle-mode #puzzleShield {
      display: block;
    }

    /* Mirror canvas ‚Äî sized by JS to maintain aspect ratio (object-fit on canvas is unreliable) */
    #puzzleMirror {
      display: none;
      position: fixed;
      background: #000;
      z-index: 400;
    }
    .puzzle-mode #puzzleMirror {
      display: block;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- LIBRARY VIEW -->
    <div id="libraryView" class="active">
      <div class="header">
        <h1>RETRO ARCADE</h1>
        <div class="header-subtitle">Tap a game to play</div>
        <div class="version-tag">v19</div>
      </div>
      <div class="library-content">
        <div id="emptyState" class="empty-state">
          <div class="empty-state-icon">üéÆ</div>
          <p>No games yet ‚Äî tap the Ôºã button below to add your game files</p>
        </div>
        <div id="gamesGrid" class="games-grid" style="display: none;"></div>
      </div>
      <button class="add-button" id="addButton">Ôºã</button>
      <input type="file" id="fileInput" multiple accept=".nes,.smc,.sfc,.snes,.gb,.gbc,.gba,.md,.gen,.bin,.sms,.zip,.chd,.pbp,.iso,.cue">
    </div>

    <!-- PLAYER VIEW -->
    <div id="playerView">
      <div id="puzzleShield"></div>
      <canvas id="puzzleMirror"></canvas>
      <div id="touchOverlay"></div>
      <div class="hold-indicator" id="holdIndicator">‚ñº Dropping fast</div>
      <button class="back-button" id="backButton">‚Üê Back to Games</button>
      <div class="loading-screen" id="loadingScreen">
        <div class="spinner"></div>
        <div class="loading-text">Loading game...</div>
      </div>
      <div id="game-container"></div>
    </div>
  </div>

  <!-- MODALS -->
  <div class="modal-overlay" id="systemPickerModal">
    <div class="modal">
      <h2>Select System</h2>
      <div class="system-picker" id="systemPicker"></div>
      <div class="modal-buttons">
        <button class="modal-button secondary" onclick="cancelSystemPicker()">Cancel</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="deleteModal">
    <div class="modal delete-modal">
      <h2>Delete Game?</h2>
      <p>Are you sure you want to delete <span class="game-name" id="deleteGameName"></span>?</p>
      <div class="modal-buttons">
        <button class="modal-button secondary" onclick="cancelDelete()">Cancel</button>
        <button class="modal-button primary" onclick="confirmDelete()">Delete</button>
      </div>
    </div>
  </div>

  <script>
    // ===== CONSTANTS & CONFIG =====
    const DB_NAME = 'retroarcade';
    const DB_STORE = 'games';
    const EMULATOR_CDN = 'https://cdn.emulatorjs.org/stable/data/';

    const SYSTEM_MAP = {
      'nes': { name: 'NES', icon: 'üî¥', extensions: ['nes'], color: '#ff6b35' },
      'snes': { name: 'SNES', icon: 'üü™', extensions: ['smc', 'sfc', 'snes'], color: '#a946ef' },
      'gb': { name: 'Game Boy', icon: 'üü©', extensions: ['gb', 'gbc'], color: '#8ab83a' },
      'gba': { name: 'GBA', icon: 'üü¶', extensions: ['gba'], color: '#7c5295' },
      'segaMD': { name: 'Genesis', icon: '‚¨õ', extensions: ['md', 'gen', 'bin'], color: '#0070cc' },
      'segaMS': { name: 'Master System', icon: '‚¨õ', extensions: ['sms'], color: '#000' },
      'psx': { name: 'PlayStation', icon: 'üéÆ', extensions: ['chd', 'pbp', 'iso', 'cue'], color: '#003087' }
    };

    let db;
    let currentGameId = null;
    let pendingZipFile = null;
    let currentBlobUrl = null;
    let backButtonTimer = null;
    let currentControlScheme = null;
    let touchState = { active: false, startX: 0, startY: 0, startTime: 0, holdTimer: null, holdActive: false, moved: false };

    // ===== DATABASE INITIALIZATION =====
    async function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };

        request.onupgradeneeded = (event) => {
          const database = event.target.result;
          if (!database.objectStoreNames.contains(DB_STORE)) {
            database.createObjectStore(DB_STORE, { keyPath: 'id' });
          }
        };
      });
    }

    // ===== GAMES DATABASE OPERATIONS =====
    async function getAllGames() {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([DB_STORE], 'readonly');
        const store = transaction.objectStore(DB_STORE);
        const request = store.getAll();

        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
          const games = request.result;
          games.sort((a, b) => {
            if (a.system !== b.system) {
              return Object.keys(SYSTEM_MAP).indexOf(a.core) - Object.keys(SYSTEM_MAP).indexOf(b.core);
            }
            return a.name.localeCompare(b.name);
          });
          resolve(games);
        };
      });
    }

    async function getGameById(id) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([DB_STORE], 'readonly');
        const store = transaction.objectStore(DB_STORE);
        const request = store.get(id);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
      });
    }

    async function saveGame(game) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([DB_STORE], 'readwrite');
        const store = transaction.objectStore(DB_STORE);
        const request = store.add(game);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
      });
    }

    async function updateGame(game) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([DB_STORE], 'readwrite');
        const store = transaction.objectStore(DB_STORE);
        const request = store.put(game);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
      });
    }

    async function deleteGame(id) {
      return new Promise((resolve, reject) => {
        const transaction = db.transaction([DB_STORE], 'readwrite');
        const store = transaction.objectStore(DB_STORE);
        const request = store.delete(id);

        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve();
      });
    }

    // ===== FILE HANDLING =====
    function getExtension(filename) {
      return filename.split('.').pop().toLowerCase();
    }

    function getCoreFromExtension(ext) {
      for (const [core, info] of Object.entries(SYSTEM_MAP)) {
        if (info.extensions.includes(ext)) {
          return core;
        }
      }
      return null;
    }

    function cleanGameName(filename) {
      return filename
        .replace(/\.[^/.]+$/, '')
        .replace(/[_-]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function showSystemPicker(file) {
      pendingZipFile = file;
      const picker = document.getElementById('systemPicker');
      picker.innerHTML = '';

      Object.entries(SYSTEM_MAP).forEach(([core, info]) => {
        const div = document.createElement('div');
        div.className = 'system-option';
        div.innerHTML = `<div class="system-option-icon">${info.icon}</div><div class="system-option-name">${info.name}</div>`;
        div.onclick = () => selectSystemForZip(core);
        picker.appendChild(div);
      });

      document.getElementById('systemPickerModal').classList.add('active');
    }

    function selectSystemForZip(core) {
      if (!pendingZipFile) return;

      const file = pendingZipFile;
      const reader = new FileReader();

      reader.onload = async (e) => {
        const gameName = cleanGameName(file.name);
        const game = {
          id: Date.now() + Math.random(),
          name: gameName,
          system: SYSTEM_MAP[core].name,
          core: core,
          romBlob: new Blob([e.target.result], { type: 'application/zip' }),
          dateAdded: new Date().toISOString()
        };

        await saveGame(game);
        await renderLibrary();
        closeSytemPicker();
      };

      reader.readAsArrayBuffer(file);
    }

    function cancelSystemPicker() {
      pendingZipFile = null;
      document.getElementById('systemPickerModal').classList.remove('active');
    }

    const closeSytemPicker = cancelSystemPicker;

    async function handleFileSelect(event) {
      const files = event.target.files;
      if (!files.length) return;

      for (let file of files) {
        const ext = getExtension(file.name);
        const core = getCoreFromExtension(ext);

        if (ext === 'zip') {
          showSystemPicker(file);
          continue;
        }

        if (!core) continue;

        const reader = new FileReader();
        reader.onload = async (e) => {
          const gameName = cleanGameName(file.name);
          const game = {
            id: Date.now() + Math.random(),
            name: gameName,
            system: SYSTEM_MAP[core].name,
            core: core,
            romBlob: new Blob([e.target.result]),
            dateAdded: new Date().toISOString()
          };

          await saveGame(game);
          await renderLibrary();
        };
        reader.readAsArrayBuffer(file);
      }

      event.target.value = '';
    }

    // ===== UI RENDERING =====
    async function renderLibrary() {
      const games = await getAllGames();
      const grid = document.getElementById('gamesGrid');
      const emptyState = document.getElementById('emptyState');

      if (games.length === 0) {
        grid.style.display = 'none';
        emptyState.style.display = 'flex';
        return;
      }

      grid.style.display = 'grid';
      emptyState.style.display = 'none';
      grid.innerHTML = '';

      games.forEach((game) => {
        const card = document.createElement('div');
        card.className = 'game-card';
        const coreInfo = SYSTEM_MAP[game.core];
        const icon = coreInfo.icon;

        card.innerHTML = `
          <button class="game-card-delete-btn" onclick="event.stopPropagation(); showDeleteConfirm('${game.id}', '${game.name.replace(/'/g, "\\'")}')">‚úï</button>
          <div class="game-card-icon">${icon}</div>
          <div class="game-card-name">${game.name}</div>
          <div class="game-card-system ${game.core}">${coreInfo.name}</div>
          <div class="game-card-hint">Tap to play</div>
        `;

        card.onclick = () => playGame(game.id);

        grid.appendChild(card);
      });
    }

    // ===== CUSTOM TOUCH CONTROLS =====
    // EmulatorJS NES button indices (libretro standard)
    const NES = { B: 0, SELECT: 2, START: 3, UP: 4, DOWN: 5, LEFT: 6, RIGHT: 7, A: 8 };

    function emuInput(index, value) {
      try {
        if (window.EJS_emulator && window.EJS_emulator.gameManager) {
          window.EJS_emulator.gameManager.simulateInput(0, index, value);
        }
      } catch(e) {}
    }

    function pressButton(index) { emuInput(index, 1); }
    function releaseButton(index) { emuInput(index, 0); }
    function tapButton(index, duration = 80) {
      pressButton(index);
      setTimeout(() => releaseButton(index), duration);
    }

    // Randomize NES PRNG by auto-pressing START after a random delay.
    // Magic Jewelry (and most NES puzzle games) seed their piece sequence from
    // the frame counter at the moment START is pressed. A random delay of 500-4000ms
    // means ~30-240 different frame counts, giving distinct piece sequences each session.
    function randomizeAndStart() {
      let attempts = 0;
      const tryStart = () => {
        if (window.EJS_emulator && window.EJS_emulator.gameManager) {
          const randomDelay = 500 + Math.floor(Math.random() * 3500); // 500-4000ms
          setTimeout(() => {
            // Press START to begin gameplay ‚Äî frame counter is now different each time
            tapButton(NES.START);
          }, randomDelay);
        } else if (attempts < 30) {
          attempts++;
          setTimeout(tryStart, 200);
        }
      };
      tryStart();
    }

    function showTouchFeedback(x, y) {
      const fb = document.createElement('div');
      fb.className = 'touch-feedback';
      fb.style.left = x + 'px';
      fb.style.top = y + 'px';
      document.body.appendChild(fb);
      requestAnimationFrame(() => fb.classList.add('pop'));
      setTimeout(() => fb.remove(), 400);
    }

    // Canvas mirror: copies EmulatorJS canvas onto our own canvas every frame.
    // A black shield covers game-container (hiding all EmulatorJS UI).
    // This avoids ANY CSS/JS targeting of EmulatorJS elements (which causes crashes).
    let mirrorAnimId = null;

    function sizeMirrorCanvas(mirror, srcW, srcH) {
      // Letterbox: fit source aspect ratio into viewport
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const scale = Math.min(vw / srcW, vh / srcH);
      const w = Math.round(srcW * scale);
      const h = Math.round(srcH * scale);
      mirror.style.left = Math.round((vw - w) / 2) + 'px';
      mirror.style.top = Math.round((vh - h) / 2) + 'px';
      mirror.style.width = w + 'px';
      mirror.style.height = h + 'px';
    }

    function startCanvasMirror() {
      const mirror = document.getElementById('puzzleMirror');
      const ctx = mirror.getContext('2d');
      let lastSrcW = 0, lastSrcH = 0;

      function frame() {
        const source = document.querySelector('#game-container canvas');
        if (source && source.width > 0 && source.height > 0) {
          if (mirror.width !== source.width || mirror.height !== source.height) {
            mirror.width = source.width;
            mirror.height = source.height;
          }
          // Re-letterbox if source size changed
          if (source.width !== lastSrcW || source.height !== lastSrcH) {
            lastSrcW = source.width;
            lastSrcH = source.height;
            sizeMirrorCanvas(mirror, lastSrcW, lastSrcH);
          }
          try {
            ctx.drawImage(source, 0, 0);
          } catch(e) {
            // WebGL context lost or other error ‚Äî skip this frame
          }
        }
        mirrorAnimId = requestAnimationFrame(frame);
      }
      mirrorAnimId = requestAnimationFrame(frame);
    }

    function stopCanvasMirror() {
      if (mirrorAnimId) {
        cancelAnimationFrame(mirrorAnimId);
        mirrorAnimId = null;
      }
    }

    function initPuzzleTouchControls() {
      const overlay = document.getElementById('touchOverlay');
      const holdIndicator = document.getElementById('holdIndicator');
      overlay.classList.add('active');

      // Make game-container fill viewport and clip any EmulatorJS toolbar overflow.
      // We target OUR container only ‚Äî never EmulatorJS internal DOM elements (crashes iOS).
      const container = document.getElementById('game-container');
      container.style.cssText = 'width:100vw!important;height:100vh!important;position:fixed!important;top:0!important;left:0!important;z-index:1!important;overflow:hidden!important;';

      // iOS audio unlock: AudioContext must be resumed during a user gesture.
      // Our overlay intercepts all touches, so EmulatorJS never gets the gesture.
      // We resume all AudioContexts on the first touch.
      let audioUnlocked = false;
      const unlockAudio = () => {
        if (audioUnlocked) return;
        audioUnlocked = true;
        // Find and resume any AudioContext EmulatorJS may have created
        const tryResume = () => {
          try {
            const emu = window.EJS_emulator;
            if (emu && emu.Module && emu.Module.SDL2 && emu.Module.SDL2.audioContext) {
              emu.Module.SDL2.audioContext.resume();
            }
          } catch(e) {}
          // Also create+resume a throwaway context to unlock the audio system globally
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            ctx.resume().then(() => setTimeout(() => ctx.close(), 1000));
          } catch(e) {}
        };
        tryResume();
        // Retry after a short delay (EmulatorJS may create AudioContext late)
        setTimeout(tryResume, 500);
        setTimeout(tryResume, 1500);
      };

      const DRAG_STEP = 40;       // pixels of drag = one column move
      const HOLD_DELAY = 300;     // ms before hold = drop fast
      const TAP_MAX_DURATION = 200;
      const TAP_MAX_MOVE = 15;    // max finger movement for a tap
      const DOUBLE_TAP_WINDOW = 300;

      let dragAccumX = 0;
      let lastTapTime = 0;

      overlay.addEventListener('touchstart', (e) => {
        e.preventDefault();
        unlockAudio();

        // Two-finger tap ‚Üí Start button (skip intro, pause, etc.)
        // Random delay (30-300ms) so the NES frame counter varies each time,
        // which gives different piece sequences in puzzle games.
        if (e.touches.length >= 2) {
          clearTimeout(touchState.holdTimer);
          touchState.active = false;
          tapButton(NES.START);
          return;
        }

        const touch = e.touches[0];
        touchState.active = true;
        touchState.startX = touch.clientX;
        touchState.startY = touch.clientY;
        touchState.startTime = Date.now();
        touchState.moved = false;
        touchState.holdActive = false;
        dragAccumX = 0;

        // Start hold timer ‚Äî if finger stays still, begin dropping fast
        touchState.holdTimer = setTimeout(() => {
          if (touchState.active && !touchState.moved) {
            touchState.holdActive = true;
            holdIndicator.classList.add('visible');
            pressButton(NES.DOWN);
          }
        }, HOLD_DELAY);
      }, { passive: false });

      overlay.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!touchState.active) return;
        const touch = e.touches[0];
        const totalDx = Math.abs(touch.clientX - touchState.startX);
        const totalDy = Math.abs(touch.clientY - touchState.startY);

        // If finger moved, cancel hold and switch to drag mode
        if (totalDx > TAP_MAX_MOVE || totalDy > TAP_MAX_MOVE) {
          if (!touchState.moved) {
            touchState.moved = true;
            clearTimeout(touchState.holdTimer);

            // Cancel hold drop if it was active
            if (touchState.holdActive) {
              touchState.holdActive = false;
              holdIndicator.classList.remove('visible');
              releaseButton(NES.DOWN);
            }
          }

          // Continuous drag ‚Üí move piece left/right one step at a time
          dragAccumX = touch.clientX - touchState.startX;
          const steps = Math.trunc(dragAccumX / DRAG_STEP);
          if (steps !== 0) {
            const dir = steps > 0 ? NES.RIGHT : NES.LEFT;
            for (let i = 0; i < Math.abs(steps); i++) {
              tapButton(dir, 50);
            }
            // Reset the origin so next step starts fresh
            touchState.startX += steps * DRAG_STEP;
          }
        }
      }, { passive: false });

      overlay.addEventListener('touchend', (e) => {
        e.preventDefault();
        clearTimeout(touchState.holdTimer);

        // If was holding down, release
        if (touchState.holdActive) {
          touchState.holdActive = false;
          holdIndicator.classList.remove('visible');
          releaseButton(NES.DOWN);
          touchState.active = false;
          return;
        }

        // Quick tap (no drag, no hold) ‚Üí rotate OR show back button
        const elapsed = Date.now() - touchState.startTime;
        if (!touchState.moved && elapsed < TAP_MAX_DURATION) {
          const now = Date.now();
          const touch = e.changedTouches[0];

          // Double-tap ‚Üí show/hide back button
          if (now - lastTapTime < DOUBLE_TAP_WINDOW) {
            const backBtn = document.getElementById('backButton');
            backBtn.classList.add('visible');
            clearTimeout(backButtonTimer);
            backButtonTimer = setTimeout(() => backBtn.classList.remove('visible'), 4000);
            lastTapTime = 0;
          } else {
            // Single tap ‚Üí rotate
            showTouchFeedback(touch.clientX, touch.clientY);
            tapButton(NES.A); // A button = rotate in Magic Jewelry
            lastTapTime = now;
          }
        }

        touchState.active = false;
        dragAccumX = 0;
      }, { passive: false });

      overlay.addEventListener('touchcancel', () => {
        clearTimeout(touchState.holdTimer);
        if (touchState.holdActive) {
          releaseButton(NES.DOWN);
          holdIndicator.classList.remove('visible');
        }
        touchState.active = false;
        touchState.holdActive = false;
        dragAccumX = 0;
      });
    }

    function cleanupTouchControls() {
      const overlay = document.getElementById('touchOverlay');
      overlay.classList.remove('active');
      document.getElementById('holdIndicator').classList.remove('visible');
      clearTimeout(touchState.holdTimer);
      if (touchState.holdActive) releaseButton(NES.DOWN);

      // Reset game-container styles
      const container = document.getElementById('game-container');
      container.style.cssText = '';

      currentControlScheme = null;
    }

    // ===== GAME PLAYER =====
    async function playGame(gameId) {
      currentGameId = gameId;
      const game = await getGameById(gameId);
      if (!game) return;

      document.getElementById('libraryView').classList.remove('active');
      document.getElementById('playerView').classList.add('active');
      document.getElementById('loadingScreen').classList.add('active');

      // Determine control scheme ‚Äî check rom-index.json DIRECTLY every time
      // (bypasses any IndexedDB timing/update issues)
      currentControlScheme = game.controls || 'default';
      try {
        const romIdx = await fetch('./rom-index.json');
        if (romIdx.ok) {
          const idx = await romIdx.json();
          const entry = idx.games.find(g => g.name === game.name);
          if (entry && entry.controls) {
            currentControlScheme = entry.controls;
          }
        }
      } catch(e) {}
      console.log('[RetroArcade] Playing:', game.name, '| controls:', currentControlScheme);

      await loadEmulator(game);

      // Auto-hide back button after 3 seconds, show on tap
      const backBtn = document.getElementById('backButton');
      backBtn.classList.add('visible');
      backButtonTimer = setTimeout(() => backBtn.classList.remove('visible'), 3000);

      document.getElementById('playerView').addEventListener('click', function showBack(e) {
        // Don't trigger if tapping the back button itself or EmulatorJS controls
        if (e.target.closest('.back-button')) return;
        const backBtn = document.getElementById('backButton');
        backBtn.classList.add('visible');
        clearTimeout(backButtonTimer);
        backButtonTimer = setTimeout(() => backBtn.classList.remove('visible'), 3000);
      });
    }

    function goBackToLibrary() {
      // Clear back button timer
      clearTimeout(backButtonTimer);
      document.getElementById('backButton').classList.remove('visible');
      // Clean up custom touch controls
      cleanupTouchControls();
      // Revoke blob URL
      if (currentBlobUrl) {
        URL.revokeObjectURL(currentBlobUrl);
        currentBlobUrl = null;
      }

      // Try to stop EmulatorJS properly
      try {
        // EmulatorJS stores its instance on the window
        if (window.EJS_emulator) {
          if (typeof window.EJS_emulator.pause === 'function') window.EJS_emulator.pause();
          if (typeof window.EJS_emulator.exit === 'function') window.EJS_emulator.exit();
        }
      } catch(e) { console.warn('EmulatorJS cleanup error:', e); }

      // Kill ALL audio contexts on the page
      try {
        // Close any AudioContext instances
        if (window.AudioContext || window.webkitAudioContext) {
          // EmulatorJS often stores audio context in various places
          const contexts = [];
          if (window.EJS_emulator && window.EJS_emulator.audioContext) contexts.push(window.EJS_emulator.audioContext);
          
          // Brute force: find and suspend all audio contexts
          contexts.forEach(ctx => {
            try { ctx.close(); } catch(e) {}
          });
        }
      } catch(e) {}

      // Stop all audio and video elements
      document.querySelectorAll('audio, video').forEach(el => {
        el.pause();
        el.src = '';
        el.remove();
      });

      // Nuclear option: reload the page's audio by suspending all contexts
      // EmulatorJS creates its AudioContext internally
      try {
        const iframes = document.querySelectorAll('iframe');
        iframes.forEach(f => f.remove());
      } catch(e) {}

      // Clear the game container completely
      const container = document.getElementById('game-container');
      container.innerHTML = '';

      // Remove ALL dynamically added scripts (EmulatorJS adds several)
      document.querySelectorAll('script:not([data-app])').forEach(s => {
        if (s.src && (s.src.includes('emulatorjs') || s.src.includes('cdn.emulatorjs'))) {
          s.remove();
        }
      });

      // Remove any EmulatorJS stylesheets
      document.querySelectorAll('link[href*="emulatorjs"], style[data-emulatorjs]').forEach(el => el.remove());

      // Clean up ALL EmulatorJS global variables
      const ejsKeys = Object.keys(window).filter(k => k.startsWith('EJS_'));
      ejsKeys.forEach(k => { try { delete window[k]; } catch(e) { window[k] = undefined; } });

      // Switch views
      document.getElementById('playerView').classList.remove('active');
      document.getElementById('libraryView').classList.add('active');
      document.getElementById('loadingScreen').classList.remove('active');
      currentGameId = null;
    }

    async function loadEmulator(game) {
      try {
        const romBlob = game.romBlob;
        currentBlobUrl = URL.createObjectURL(romBlob);

        window.EJS_player = '#game-container';
        window.EJS_core = game.core;
        window.EJS_gameName = game.name;
        window.EJS_pathtodata = EMULATOR_CDN;
        window.EJS_gameUrl = currentBlobUrl;
        window.EJS_color = '#ff6b35';
        window.EJS_startOnLoaded = true;
        window.EJS_fullscreenOnLoaded = false;
        window.EJS_onSaveState = () => {};
        window.EJS_onLoadState = () => {};

        // Configure UI for puzzle mode
        if (currentControlScheme === 'puzzle') {
          // Empty array = no virtual gamepad buttons at all (d-pad, A/B, etc.)
          window.EJS_VirtualGamepadSettings = [];

          // Hide every toolbar button using v4.2.2+ syntax
          window.EJS_Buttons = {
            playPause: false,
            restart: false,
            mute: false,
            settings: false,
            fullscreen: false,
            saveState: false,
            loadState: false,
            screenRecord: false,
            gamepad: false,
            cheat: false,
            volume: false,
            saveSavFiles: false,
            loadSavFiles: false,
            quickSave: false,
            quickLoad: false,
            screenshot: false,
            cacheManager: false,
            exitEmulation: false
          };
        }

        const script = document.createElement('script');
        script.src = EMULATOR_CDN + 'loader.js';
        script.async = true;

        script.onload = () => {
          // Wait for EmulatorJS to fully initialize before activating custom controls
          setTimeout(() => {
            document.getElementById('loadingScreen').classList.remove('active');
            // NOW activate puzzle touch controls (after emulator is running)
            if (currentControlScheme === 'puzzle') {
              // Auto-press START after random delay so piece sequence differs each session
              randomizeAndStart();
              // Activate custom touch controls (emulator UI hidden via EJS_Buttons/EJS_VirtualGamepadSettings)
              initPuzzleTouchControls();
            }
          }, 2500);
        };

        script.onerror = () => {
          console.error('Failed to load EmulatorJS');
          document.getElementById('loadingScreen').classList.remove('active');
          alert('Failed to load emulator. Check your connection and try again.');
        };

        document.body.appendChild(script);
      } catch (error) {
        console.error('Error loading game:', error);
        document.getElementById('loadingScreen').classList.remove('active');
        alert('Error loading game. Please try again.');
      }
    }

    // ===== DELETE FUNCTIONALITY =====
    function showDeleteConfirm(gameId, gameName) {
      currentGameId = gameId;
      document.getElementById('deleteGameName').textContent = gameName;
      document.getElementById('deleteModal').classList.add('active');
    }

    function cancelDelete() {
      document.getElementById('deleteModal').classList.remove('active');
      currentGameId = null;
    }

    async function confirmDelete() {
      if (currentGameId) {
        await deleteGame(currentGameId);
        await renderLibrary();
        cancelDelete();
      }
    }

    // ===== EVENT LISTENERS =====
    document.getElementById('addButton').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', handleFileSelect);

    document.getElementById('backButton').addEventListener('click', goBackToLibrary);

    // ===== SERVICE WORKER REGISTRATION =====
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').then((reg) => {
        // Force check for updates immediately
        reg.update();
        // When a new SW is found, tell it to activate immediately
        reg.addEventListener('updatefound', () => {
          const newWorker = reg.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'activated') {
                // New SW active ‚Äî reload to get fresh content
                window.location.reload();
              }
            });
          }
        });
      }).catch((err) => {
        console.log('Service Worker registration failed:', err);
      });
    }

    // ===== FOLDER-BASED ROM LOADING =====
    async function loadFolderGames() {
      try {
        const response = await fetch('./rom-index.json');
        if (!response.ok) return;
        const index = await response.json();
        
        const existingGames = await getAllGames();
        const existingByName = {};
        existingGames.forEach(g => { existingByName[g.name] = g; });

        for (const entry of index.games) {
          const existing = existingByName[entry.name];

          if (existing) {
            // Game exists ‚Äî update controls field if it changed or was missing
            const newControls = entry.controls || 'default';
            if (existing.controls !== newControls) {
              existing.controls = newControls;
              await updateGame(existing);
            }
            continue;
          }

          try {
            const romResponse = await fetch(entry.path);
            if (!romResponse.ok) continue;
            const romBlob = await romResponse.blob();

            const game = {
              id: Date.now() + Math.random(),
              name: entry.name,
              system: entry.system,
              core: entry.core,
              romBlob: romBlob,
              dateAdded: new Date().toISOString(),
              source: 'folder',
              controls: entry.controls || 'default'
            };

            await saveGame(game);
          } catch (e) {
            console.warn('Failed to load ROM:', entry.name, e);
          }
        }
        
        await renderLibrary();
      } catch (e) {
        // rom-index.json doesn't exist or failed ‚Äî that's fine, just use IndexedDB
        console.log('No rom-index.json found, using IndexedDB only');
      }
    }

    // ===== INITIALIZATION =====
    async function init() {
      try {
        await initDB();
        await renderLibrary();
        await loadFolderGames(); // Load folder-based ROMs
      } catch (error) {
        console.error('Failed to initialize app:', error);
      }
    }

    init();
  </script>
</body>
</html>
